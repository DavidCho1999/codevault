# Part 8 테이블 렌더링 디버깅 회고

> 4번의 시도 끝에 성공한 이유와 한 번에 적중하는 방법

---

## 문제 요약

**목표**: Part 8 테이블을 Part 11처럼 HTML로 렌더링
**결과**: 4번째 시도에서 성공
**근본 원인**: DB 경로 불일치 (`obc.db` vs `data/obc.db`)

---

## 시도별 분석

### 시도 1: JSON 생성만 확인
```
행동: part8.json 생성 → "14 tables" 출력 확인
결과: 실패
놓친 것: JSON이 실제로 웹앱에서 사용되는지 확인 안 함
```

**교훈**: 출력 메시지만 믿지 말고, 실제 소비자(웹앱)에서 확인해야 함

---

### 시도 2: DB 업데이트 후 브라우저 확인
```
행동: update_part8_db.py 실행 → 브라우저에서 확인
결과: 파이프 테이블(| ... |) 텍스트로 표시
의문점: DB에 HTML인데 왜 파이프 테이블?
잘못된 추론: "캐시 문제일 것이다"
```

**교훈**: 증상과 원인을 혼동함. "파이프 테이블이 보인다"는 증상이지 원인이 아님

---

### 시도 3: 캐시 삭제 후 재시도
```
행동: .next/cache 삭제 → 페이지 새로고침
결과: 여전히 파이프 테이블 표시
의문점: 캐시가 아니면 뭐지?
```

**교훈**: 가설이 틀렸으면 다른 가설로 전환해야 함. 같은 방향 반복 X

---

### 시도 4: 데이터 흐름 추적 (성공!)
```
행동:
1. DB 내용 직접 확인 → HTML 테이블 있음 ✓
2. 브라우저 출력 확인 → 파이프 테이블 표시
3. 불일치 발견 → "DB를 읽고 있긴 한건가?"
4. db.ts 경로 확인 → 경로 불일치 발견!
5. 경로 수정 → 성공!
```

**교훈**: 데이터가 어디서 어디로 흐르는지 전체 파이프라인을 추적해야 함

---

## 왜 4번이나 걸렸나?

### 1. 가정의 함정 (Assumption Trap)
```
잘못된 가정: "DB 경로는 당연히 맞을 것이다"
현실: 경로가 틀려서 다른 DB(또는 없는 DB)를 읽고 있었음
```

**해결법**: 모든 가정을 명시적으로 검증
```bash
# 경로 검증 예시
echo "DB_PATH in code: $(grep DB_PATH src/lib/db.ts)"
echo "Actual DB: $(ls -la data/obc.db)"
```

---

### 2. 증상 기반 디버깅 (Symptom-Based Debugging)
```
증상: 파이프 테이블이 보임
추론: "변환이 안 됐나?" → "캐시 문제인가?"
실제: 변환은 됐는데, 읽는 위치가 틀림
```

**해결법**: 증상이 아닌 데이터 흐름 기반으로 디버깅
```
[Source] → [Transform] → [Store] → [Load] → [Render]
   ↓           ↓           ↓          ↓          ↓
  확인        확인        확인       확인        확인
```

---

### 3. 단일 지점 검증 (Single Point Verification)
```
내가 한 것: DB 업데이트 스크립트 출력만 확인
해야 할 것: DB 파일 직접 열어서 확인 + 웹앱이 읽는 경로 확인
```

**해결법**: 최소 2개 이상 독립적인 지점에서 검증
```python
# 1. DB에 저장됐는지 확인
sqlite3 data/obc.db "SELECT content FROM nodes WHERE id='8.2.1'" | grep '<table'

# 2. 웹앱이 올바른 DB를 읽는지 확인
grep -r "obc.db" src/
```

---

## 한 번에 적중하는 질문 프레임워크

### Step 1: 전체 파이프라인 명시
```markdown
## 데이터 흐름
1. Source: data/marker/part8.md
2. Transform: pipeline/parse_marker_part8.py
3. Store: data/obc.db (nodes 테이블)
4. Load: codevault/src/lib/db.ts
5. Render: codevault/src/components/code/SectionView.tsx
```

### Step 2: 각 단계별 검증 질문
```markdown
## 검증 체크리스트
- [ ] Source 파일이 존재하고 예상 형식인가?
- [ ] Transform 결과물이 예상 형식인가?
- [ ] Store에 올바르게 저장됐는가?
- [ ] Load가 올바른 위치에서 읽는가? ← 이번에 놓침!
- [ ] Render가 올바르게 처리하는가?
```

### Step 3: 불일치 탐지
```markdown
## 불일치 체크
| 단계 | 예상 | 실제 | 일치? |
|------|------|------|-------|
| DB 내용 | HTML table | HTML table | ✓ |
| 웹 출력 | HTML table | 파이프 텍스트 | ✗ ← 불일치! |

불일치 발생 → Load 또는 Render 단계 문제
```

---

## Claude에게 더 효과적으로 물어보는 법

### Bad: 증상만 설명
```
"테이블이 안 나와요"
```

### Good: 파이프라인 + 검증 결과 포함
```
"Part 8 테이블 렌더링 문제

## 파이프라인
1. Marker → JSON 변환 완료 (14 tables)
2. JSON → DB 저장 완료 (7 HTML tables 확인)
3. 웹에서 파이프 테이블 텍스트로 표시됨

## 검증 결과
- DB 쿼리: <table class="obc-table"> 있음
- 브라우저: | ... | 파이프 텍스트 표시

## 질문
Load 단계(db.ts)가 올바른 DB를 읽고 있는지 확인해줘"
```

---

## 빠른 디버깅 체크리스트

```markdown
## 데이터 흐름 문제 디버깅

### 1. 경로 확인 (30초)
- [ ] 코드에 하드코딩된 경로 확인
- [ ] 실제 파일 위치와 비교
- [ ] 상대경로 vs 절대경로 주의

### 2. 읽기/쓰기 지점 확인 (1분)
- [ ] 스크립트가 어디에 쓰는가?
- [ ] 앱이 어디서 읽는가?
- [ ] 두 경로가 일치하는가?

### 3. 버전/캐시 확인 (1분)
- [ ] 파일 수정 시간 확인 (ls -la)
- [ ] 캐시 삭제 (.next/cache, __pycache__)
- [ ] 서버 재시작

### 4. 직접 검증 (2분)
- [ ] DB 직접 쿼리로 확인
- [ ] 콘솔 로그로 런타임 확인
- [ ] 네트워크 탭에서 응답 확인
```

---

## 이번 케이스 요약

| 항목 | 내용 |
|------|------|
| 근본 원인 | DB 경로 불일치 (`obc.db` vs `data/obc.db`) |
| 발견 방법 | DB 내용 ↔ 웹 출력 불일치 → 경로 추적 |
| 해결 | `db.ts`에서 `data/obc.db`로 경로 수정 |
| 소요 시간 | 4회 시도 (약 20분) |
| 이상적 시간 | 1회 시도 (약 5분) - 경로 먼저 확인했으면 |

---

## 기억할 원칙

> **"데이터가 어디서 어디로 가는지 추적하라"**
>
> 증상만 보지 말고, 파이프라인 전체를 따라가라.
> 각 단계에서 예상값과 실제값을 비교하라.
> 불일치가 발생한 지점이 문제의 원인이다.

---

*작성일: 2026-01-20*
*관련 파일: db.ts, parse_marker_part8.py, update_part8_db.py*
